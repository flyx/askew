package runtime

import (
	"github.com/gopherjs/gopherjs/js"
)

// ScalarAccessor is the interface for retrieving and setting a single value
// to an HTML node.
type ScalarAccessor interface {
	get() *js.Object
	set(value interface{})
}

// PropertyAccessor implements ScalarAccessor for a single property of an
// HTML node, such as `textContent` or `value`.
type PropertyAccessor struct {
	node  *js.Object
	pName string
}

// NewPropertyAccessor creates a PropertyAccessor for the node found at the
// given path (relative to root) and the given property name.
func NewPropertyAccessor(root *js.Object, path []int, pName string) *PropertyAccessor {
	return &PropertyAccessor{
		node: WalkPath(root, path), pName: pName}
}

func (pa *PropertyAccessor) get() *js.Object {
	return pa.node.Get(pa.pName)
}

func (pa *PropertyAccessor) set(value interface{}) {
	pa.node.Set(pa.pName, value)
}

// ClassSwitcher implements ScalarAccessor for a node so that assigning boolean
// values to it switches a class with a given name on or off on the target node.
// may only be used with boolean values.
type ClassSwitcher struct {
	node      *js.Object
	className string
}

// NewClassSwitcher creates a ClassSwitcher for the node at the given path,
// which switches the class with the given name.
func NewClassSwitcher(root *js.Object, path []int, className string) *ClassSwitcher {
	return &ClassSwitcher{
		node: WalkPath(root, path), className: className}
}

func (cs *ClassSwitcher) get() *js.Object {
	return cs.node.Get("classList").Call("contains", cs.className)
}

func (cs *ClassSwitcher) set(value interface{}) {
	if value.(bool) {
		cs.node.Get("classList").Call("add", cs.className)
	} else {
		cs.node.Get("classList").Call("remove", cs.className)
	}
}

// ListManager is the backend for component lists.
type ListManager struct {
	parent *js.Object
	end    *js.Object
}

// CreateListManager creates a list manager that inserts list objects at the given
// index between the children of the given parent.
func CreateListManager(parent *js.Object, insertAt int) ListManager {
	return ListManager{
		parent: parent, end: parent.Get("childNodes").Index(insertAt)}
}

// UpdateParent sets a new parent node for the manager.
// You need to do this when you move the content nodes from one container to
// another. This commonly happens if the nodes are initially part of a
// DocumentFragment (generated by instantiating a template) but are inserted
// into the main docmuent.
//
// You give the DocumentFragment as oldParent. Only if the list actually acted
// directly in that fragment, it gets updated. You give newEnd as the first node
// in the new parent after the inserted nodes; it is only relevant if this list
// acted on the last item of the DocumentFragment (if not, the node after the
// list's items stays the same).
func (lm *ListManager) UpdateParent(
	oldParent, newParent, newEnd *js.Object) {
	if oldParent == lm.parent {
		lm.parent = newParent
		if lm.end == nil {
			lm.end = newEnd
		}
	}
}

// Remove removes the given object from the container.
func (lm ListManager) Remove(o *js.Object) {
	lm.parent.Call("removeChild", o)
}

// Append appends the given object to the container.
func (lm ListManager) Append(o *js.Object) {
	lm.parent.Call("insertBefore", o, lm.end)
}

// Insert inserts the given object in front of the object `before`.
func (lm ListManager) Insert(o *js.Object, before *js.Object) {
	lm.parent.Call("insertBefore", o, before)
}

// StringValue provides access to a dynamic value of string type.
type StringValue struct {
	ScalarAccessor
}

// Get returns the current string value of the linked node.
func (sv *StringValue) Get() string {
	return sv.get().String()
}

// Set updates the underlying node with the given value.
func (sv *StringValue) Set(value string) {
	sv.set(value)
}

// IntValue provides access to a dynamic value of int type.
type IntValue struct {
	ScalarAccessor
}

// Get returns the current value of the linked node.
func (iv *IntValue) Get() int {
	return iv.get().Int()
}

// Set updates the underlying node with the given value.
func (iv *IntValue) Set(value int) {
	iv.set(value)
}

// BoolValue provides access to a dynamic value of bool type.
type BoolValue struct {
	ScalarAccessor
}

// Get returns the current value of the linked node.
func (bv *BoolValue) Get() bool {
	return bv.get().Bool()
}

// Set updates the underlying node with the given value.
func (bv *BoolValue) Set(value bool) {
	bv.set(value)
}
