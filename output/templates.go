package output

import (
	"fmt"
	"strings"
	"text/template"

	"github.com/flyx/askew/data"
)

var fileHeader = template.Must(template.New("fileHeader").Parse(`
package {{.PackageName}}

import (
	"github.com/flyx/askew/runtime"
	"github.com/gopherjs/gopherjs/js"
	{{- range $dep, $_ := .Deps }}
	"{{$dep}}"{{ end }}
)
`))

var component = template.Must(template.New("component").Funcs(template.FuncMap{
	"Wrapper":      wrapperForType,
	"PathItems":    pathItems,
	"NameForBound": nameForBound,
	"ParentPath":   parentPath,
	"Last":         last,
	"GenParams": func(params map[string]data.VariableType) string {
		var items []string
		for pName, pType := range params {
			items = append(items, pName+" "+nameForType(pType))
		}
		return strings.Join(items, ", ")
	},
	"GenArgs": func(params map[string]data.BoundValue) string {
		items := make([]string, 0, len(params))
		for name := range params {
			items = append(items, fmt.Sprintf("&p%s", name))
		}
		return strings.Join(items, ", ")
	},
	"Constructor": func(bk data.BoundKind) string {
		switch bk {
		case data.BoundProperty:
			return "NewBoundProperty"
		case data.BoundData:
			return "NewBoundData"
		case data.BoundClass:
			return "NewBoundClass"
		default:
			panic("unknown BoundKind")
		}
	},
	"GenCallParams": func(params map[string]data.VariableType) string {
		items := make([]string, 0, len(params))
		for name := range params {
			items = append(items, name+" runtime.BoundValue")
		}
		return strings.Join(items, ", ")
	},
	"GenTypedArgs": func(params map[string]data.VariableType) string {
		items := make([]string, 0, len(params))
		for name := range params {
			items = append(items, fmt.Sprintf("_%s.Get()", name))
		}
		return strings.Join(items, ", ")
	},
}).Option("missingkey=error").Parse(`
{{- if and .NeedsController .Handlers}}
// {{.Name}}Controller is the interface for handling events captured from {{.Name}}
type {{.Name}}Controller interface {
	{{- range $name, $handler := .Handlers }}
	{{$name}}({{GenParams $handler.Params }}) bool
	{{- end }}
}
{{- end}}

// {{.Name}} is a DOM component autogenerated by Askew
type {{.Name}} struct {
	root *js.Object
	{{- if and .NeedsController .Handlers }}
	// Controller is the object handling captured events.
	// if nil, events will not be captured.
	Controller {{.Name}}Controller
	{{- end}}
	{{- range .Variables }}
	{{.Name}} runtime.{{Wrapper .Type}}
	{{- end}}
	{{- range .Embeds }}
	{{.Field}} {{if not .List}}*{{end}}{{with .Pkg}}{{.}}.{{end}}{{.T}}{{if .List}}List{{end}}
	{{- end}}
}

// New{{.Name}} creates a new component and initializes it with Init.
func New{{.Name}}() *{{.Name}} {
	ret := new({{.Name}})
	ret.Init()
	return ret
}

// Init initializes the component, discarding all previous information.
// The component is initially a DocumentFragment until it gets inserted into
// the main document. It can be manipulated both before and after insertion.
func (o *{{.Name}}) Init() {
	o.root = runtime.InstantiateTemplateByID("{{.ID}}")
	{{ range .Variables }}
	o.{{.Name}}.BoundValue = runtime.{{Constructor .Value.Kind}}(o.root, "{{.Value.ID}}", {{PathItems .Path}})
	{{- end}}
	{{- range .Embeds }}
	{
		container := runtime.WalkPath(o.root, {{ParentPath .Path}})
		{{- if .List}}
		o.{{.Field}}.Init(container, {{Last .Path}})
		{{- else}}
		o.{{.Field}} = {{with .Pkg}}{{.}}.{{end}}New{{.T}}()
		o.{{.Field}}.InsertInto(container, container.Get("childNodes").Index({{Last .Path}}))
		{{- end}}
	}
	{{- end}}
	{{- range .Captures}}
	{
		src := runtime.WalkPath(o.root, {{PathItems .Path}})
		{{- range .Mappings}}
		{
			wrapper := js.MakeFunc(func(this *js.Object, arguments []*js.Object) interface{} {
				{{- range $pName, $bVal := .ParamMappings}}
				var p{{$pName}} runtime.{{NameForBound $bVal.Kind}}
				p{{$pName}}.Init(this, "{{$bVal.ID}}")
				{{- end}}
				if o.call{{.Handler}}({{GenArgs .ParamMappings}}) {
					arguments[0].Call("preventDefault")
				}
				return nil
			})
			src.Call("addEventListener", "{{.Event}}", wrapper)
		}
		{{- end}}
	}
	{{- end}}
}

// InsertInto inserts this component into the given object. This can only
// be done once. The nodes will be inserted in front of 'before', or
// at the end if 'before' is 'nil'.
func (o *{{.Name}}) InsertInto(parent *js.Object, before *js.Object) {
	parent.Call("insertBefore", o.root, before)
	{{- range .Embeds}}
	{{- if .List}}
	o.{{.Field}}.mgr.UpdateParent(o.root, parent, before)
	{{- end}}
	{{- end}}
}

{{- range $hName, $h := .Handlers}}
func (o *{{$.Name}}) call{{$hName}}({{GenCallParams $h.Params}}) bool {
	{{if $.NeedsController}}
	if o.Controller == nil {
		return false
	}
	{{- end}}
	{{- range $pName, $pType := $h.Params}}
	_{{$pName}} := runtime.{{Wrapper $pType}}{BoundValue: {{$pName}}}
	{{- end}}
	{{- if $.NeedsController}}
	return o.Controller
	{{- else}}
	return o
	{{- end}}.{{$hName}}({{GenTypedArgs $h.Params}})
}
{{- end}}

{{if .NeedsList}}
// {{.Name}}List is a list of {{.Name}} whose manipulation methods auto-update
// the corresponding nodes in the document.
type {{.Name}}List struct {
	mgr runtime.ListManager
	items []*{{.Name}}
}

// Init initializes the list, discarding previous data.
// The list's items will be placed in the given container, starting at the
// given index.
func (l *{{.Name}}List) Init(container *js.Object, index int) {
	l.mgr = runtime.CreateListManager(container, index)
	l.items = nil
}

// Len returns the number of items in the list.
func (l *{{.Name}}List) Len() int {
	return len(l.items)
}

// Item returns the item at the current index.
func (l *{{.Name}}List) Item(index int) *{{.Name}}{
	return l.items[index]
}

// Append appends the given item to the list and returns it.
// If item is nil, a new item is created and returned.
func (l *{{.Name}}List) Append(item *{{.Name}}) (ret *{{.Name}}) {
	if item == nil {
		ret = New{{.Name}}()
	} else {
		ret = item
	}
	l.items = append(l.items, ret)
	l.mgr.Append(ret.root)
	return
}

// Insert inserts the given item at the given index into the list and returns it.
// If item is nil, a new item is created and returned.
func (l *{{.Name}}List) Insert(index int, item *{{.Name}}) (ret *{{.Name}}) {
	var prev *js.Object
	if index < len(l.items) {
		prev = l.items[index].root
	}
	if item == nil {
		ret = New{{.Name}}()
	} else {
		ret = item
	}
	l.items = append(l.items, nil)
	copy(l.items[index+1:], l.items[index:])
	l.items[index] = ret
	l.mgr.Insert(ret.root, prev)
	return
}

// Remove removes the item at the given index from the list.
func (l *{{.Name}}List) Remove(index int) {
	l.mgr.Remove(l.items[index].root)
	copy(l.items[index:], l.items[index+1:])
	l.items = l.items[:len(l.items)-1]
}
{{end}}
`))

var skeleton = template.Must(template.New("skeleton").Funcs(template.FuncMap{
	"ParentPath": parentPath,
	"Last":       last,
}).Parse(`
{{range .Embeds}}
{{if .List}}
var {{.Field}} {{.Pkg}}.{{.T}}List
{{else}}
var {{.Field}} = {{.Pkg}}.New{{.T}}()
{{end}}
{{end}}

func init() {
	document := js.Global.Get("document")
	{{- range .Embeds}}
	{{- if .List}}
	{{.Field}}.Init(runtime.WalkPath(document, {{ParentPath .Path}}), {{Last .Path}})
	{{- else}}
	{
		container := runtime.WalkPath(document, {{ParentPath .Path}})
		{{.Field}}.InsertInto(container, container.Get("childNodes").Index({{Last .Path}}))
	}
	{{- end}}
	{{- end}}
}
`))
