package main

import (
	"bytes"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"reflect"
	"strings"

	"golang.org/x/net/html/atom"

	"golang.org/x/net/html"
)

type processor struct {
	templates templateSet
	counter   int
}

func (p *processor) processTemplate(n *html.Node) {
	var tmplAttrs templateAttribs
	extractTbcAttribs(n, &tmplAttrs)
	if len(tmplAttrs.name) == 0 {
		panic("<template> must have tbc:name!")
	}
	if attrExists(n.Attr, "id") {
		panic("<template> may not have id (id is generated by tbc)")
	}

	tmpl := &template{strippedHTML: n}
	p.counter++
	tmpl.id = fmt.Sprintf("tbc-component-%d-%s", p.counter, strings.ToLower(tmplAttrs.name))
	n.Attr = append(n.Attr, html.Attribute{Key: "id", Val: tmpl.id})
	indexList := make([]int, 1, 32)
	for c := n.FirstChild; c != nil; c = c.NextSibling {
		tmpl.process(p.templates, c, indexList)
		indexList[0]++
	}
	p.templates[tmplAttrs.name] = tmpl
}

// dummy body node to be used for fragment parsing
var bodyEnv = html.Node{
	Type:     html.ElementNode,
	Data:     "body",
	DataAtom: atom.Body}

func (p *processor) process(file string) {
	contents, err := ioutil.ReadFile(file)
	if err != nil {
		log.Println(file + ": unable to read file, skipping.")
		return
	}
	nodes, err := html.ParseFragment(bytes.NewReader(contents), &bodyEnv)
	if err != nil {
		log.Printf("%s: failed to parse with error(s):\n  %s\n", file, err.Error())
		return
	}
	{
		ip := includesProcessor{}
		ip.process(&nodes)

		// we need to write out the nodes and parse it again since text nodes may
		// be merged and additional elements may be created now with includes
		// processed. If we don't do this, paths to access the dynamic objects will
		// be wrong.
		b := strings.Builder{}
		for i := range nodes {
			html.Render(&b, nodes[i])
		}
		nodes, err = html.ParseFragment(strings.NewReader(b.String()), &bodyEnv)
		if err != nil {
			panic(err)
		}
	}

	for i := range nodes {
		n := nodes[i]
		switch n.Type {
		case html.TextNode:
			text := strings.TrimSpace(n.Data)
			if len(text) > 0 {
				panic("non-whitespace text at top level: `" + text + "`")
			}
		case html.ErrorNode:
			panic("encountered ErrorNode: " + n.Data)
		case html.ElementNode:
			if n.DataAtom != atom.Template {
				panic("non-template element at top level: <" + n.Data + ">")
			}
			p.processTemplate(n)
		default:
			panic("illegal node at top level: " + n.Data)
		}
	}
}

func writePathLiteral(b *strings.Builder, path []int) {
	b.WriteString("[]int{")
	for i := range path {
		fmt.Fprintf(b, "%d, ", path[i])
	}
	b.WriteByte('}')
}

type goRenderer struct {
	templates   templateSet
	packageName string
	packagePath string
}

func (r *goRenderer) writeFileHeader(b *strings.Builder) {
	fmt.Fprintf(b, "package %s\n\n", r.packageName)
	b.WriteString("import (\n\"github.com/flyx/tbc/runtime\"\n\"github.com/gopherjs/gopherjs/js\"\n)\n")
}

func (r *goRenderer) writeFormatted(goCode string, file string) {
	fmtcmd := exec.Command("gofmt")

	var stdout bytes.Buffer
	var stderr bytes.Buffer
	fmtcmd.Stdout = &stdout
	fmtcmd.Stderr = &stderr

	stdin, err := fmtcmd.StdinPipe()
	if err != nil {
		panic("unable to create stdin pipe: " + err.Error())
	}
	io.WriteString(stdin, goCode)
	stdin.Close()

	if err := fmtcmd.Run(); err != nil {
		log.Println("error while formatting: " + err.Error())
		log.Println("stderr output:")
		log.Println(stderr.String())
		log.Println("input:")
		log.Println(goCode)
		panic("failed to format Go code")
	}

	ioutil.WriteFile(file, []byte(stdout.String()), os.ModePerm)
}

func (r *goRenderer) writeComponentFile(name string, c *template) {
	b := strings.Builder{}
	r.writeFileHeader(&b)
	fmt.Fprintf(&b, "type %s struct {\n", name)
	b.WriteString("root *js.Object\n")
	for i := range c.objects {
		o := c.objects[i]
		b.WriteString(o.goName)
		b.WriteByte(' ')
		switch o.goType {
		case reflect.Int:
			b.WriteString("runtime.IntValue\n")
		case reflect.String:
			b.WriteString("runtime.StringValue\n")
		default:
			panic("unexpected type of dynamic object")
		}
	}
	for i := range c.embeds {
		e := c.embeds[i]
		fmt.Fprintf(&b, "%s *%s", e.fieldName, e.goName)
	}

	fmt.Fprintf(&b, "}\nfunc New%s() *%s {\n", name, name)
	fmt.Fprintf(&b, "root := runtime.InstantiateTemplateByID(\"%s\")\n", c.id)
	fmt.Fprintf(&b, "ret := &%s{root: root}\n", name)
	for i := range c.objects {
		o := c.objects[i]
		fmt.Fprintf(&b, "ret.%s = ", o.goName)
		switch o.goType {
		case reflect.Int:
			b.WriteString("runtime.IntValue{")
		case reflect.String:
			b.WriteString("runtime.StringValue{")
		}
		var propertyName string
		switch o.kind {
		case textContent:
			propertyName = "textContent"
		case inputValue:
			propertyName = "value"
		}
		b.WriteString("runtime.NewPropertyAccessor(root, ")
		writePathLiteral(&b, o.path)
		fmt.Fprintf(&b, ", \"%s\")}\n", propertyName)
	}
	for i := range c.embeds {
		e := c.embeds[i]
		fmt.Fprintf(&b, "ret.%s = New%s()", e.fieldName, e.goName)
		b.WriteString("{\ntarget := runtime.WalkPath(root, ")
		writePathLiteral(&b, e.path)
		fmt.Fprintf(&b,
			")\ntarget.Call(\"parentNode\").Call(\"replaceChild\", ret.%s.Root(), target)\n}\n",
			name)
	}
	fmt.Fprintf(&b, "return ret\n}\nfunc (o *%s) Root() *js.Object {\n", name)
	b.WriteString("return o.root\n}\n")

	r.writeFormatted(b.String(), filepath.Join(r.packagePath, strings.ToLower(name)+".go"))
}

func (p *processor) dump(htmlPath, packagePath string) {
	htmlFile, err := os.Create(htmlPath)
	if err != nil {
		panic("unable to write HTML output: " + err.Error())
	}
	for i := range p.templates {
		html.Render(htmlFile, p.templates[i].strippedHTML)
	}
	htmlFile.Close()

	_, packageName := filepath.Split(packagePath)

	renderer := goRenderer{templates: p.templates, packageName: packageName,
		packagePath: packagePath}

	for name, t := range p.templates {
		renderer.writeComponentFile(name, t)
	}
}
