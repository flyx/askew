package main

import (
	"bytes"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"reflect"
	"regexp"
	"strings"

	"golang.org/x/net/html/atom"

	"golang.org/x/net/html"
)

type dynamicObjectKind int

const (
	textContent dynamicObjectKind = iota
	inputValue
)

type dynamicObject struct {
	kind   dynamicObjectKind
	path   []int
	goType reflect.Kind
	goName string
}

type template struct {
	kind templateKind
	id   string
	// maps CSS selector to object description.
	// used to ensure selectors are unique.
	objects      []dynamicObject
	strippedHTML *html.Node
	goName       string
}

type processor struct {
	templates []template
	counter   int
}

func attrVal(a []html.Attribute, name string) string {
	for i := range a {
		if a[i].Key == name {
			return a[i].Val
		}
	}
	return ""
}

func attrExists(a []html.Attribute, name string) bool {
	for i := range a {
		if a[i].Key == name {
			return true
		}
	}
	return false
}

var isValidIdentifier = regexp.MustCompile(`^[\pL_][\pL0-9]*$`).MatchString

func (t *template) gatherObjects(n *html.Node, indexList []int) {
	meta := extractTbcAttribs(n)
	switch n.DataAtom {
	case atom.Input:
		if meta.interactive == inactive {
			return
		}
		var goType reflect.Kind
		switch inputType := attrVal(n.Attr, "type"); inputType {
		case "number", "range":
			if strings.ContainsRune(attrVal(n.Attr, "min"), '.') ||
				strings.ContainsRune(attrVal(n.Attr, "max"), '.') ||
				strings.ContainsRune(attrVal(n.Attr, "step"), '.') {
				panic("non-integer " + inputType + " inputs not supported")
			}
			goType = reflect.Int
		case "", "text", "submit":
			goType = reflect.String
		default:
			panic("input type not supported: " + inputType)
		}
		htmlName := attrVal(n.Attr, "name")
		if len(htmlName) == 0 {
			panic("<input> misses a name!")
		}
		goName := htmlName
		if len(meta.name) > 0 {
			goName = meta.name
		}
		if !isValidIdentifier(goName) {
			panic("not a valid identifier: " + goName)
		}

		t.objects = append(t.objects, dynamicObject{
			kind: inputValue, path: append([]int(nil), indexList...),
			goType: goType, goName: goName})
	default:
		if meta.interactive != forceActive {
			indexList = append(indexList, 0)
			for c := n.FirstChild; c != nil; c = c.NextSibling {
				t.gatherObjects(c, indexList)
				indexList[len(indexList)-1]++
			}
			return
		}
		if n.FirstChild != nil && (n.FirstChild.Type != html.TextNode ||
			n.FirstChild.NextSibling != nil) {
			panic("tbc:dynamic on a node with child nodes")
		}
		if len(meta.name) == 0 {
			panic("tbc:dynamic on a node without tbc:name")
		}
		if !isValidIdentifier(meta.name) {
			panic("not a valid identifier: " + meta.name)
		}
		t.objects = append(t.objects, dynamicObject{
			kind: textContent, path: append([]int(nil), indexList...),
			goType: reflect.String, goName: meta.name})
	}
}

func (p *processor) processTemplate(n *html.Node) {
	meta := extractTbcAttribs(n)
	if meta.kind == noTmpl {
		panic("<template> must have tbc:kind!")
	}
	if attrExists(n.Attr, "id") {
		panic("<template> may not have id (id is generated by tbc)")
	}

	tmpl := template{kind: meta.kind, strippedHTML: n}
	p.counter++
	if meta.kind == componentTmpl {
		if len(meta.name) == 0 {
			panic("component <template> misses tbc:name!")
		}
		tmpl.goName = meta.name
		tmpl.id = fmt.Sprintf("tbc-component-%d-%s", p.counter, strings.ToLower(meta.name))
	} else {
		tmpl.id = fmt.Sprintf("tbc-macro-%d", p.counter)
	}
	n.Attr = append(n.Attr, html.Attribute{Key: "id", Val: tmpl.id})
	indexList := make([]int, 1, 32)
	for c := n.FirstChild; c != nil; c = c.NextSibling {
		tmpl.gatherObjects(c, indexList)
		indexList[0]++
	}
	p.templates = append(p.templates, tmpl)
}

// dummy body node to be used for fragment parsing
var bodyEnv = html.Node{
	Type:     html.ElementNode,
	Data:     "body",
	DataAtom: atom.Body}

func (p *processor) process(file string) {
	contents, err := ioutil.ReadFile(file)
	if err != nil {
		log.Println(file + ": unable to read file, skipping.")
		return
	}
	nodes, err := html.ParseFragment(bytes.NewReader(contents), &bodyEnv)
	if err != nil {
		log.Printf("%s: failed to parse with error(s):\n  %s\n", file, err.Error())
		return
	}
	for i := range nodes {
		n := nodes[i]
		switch n.Type {
		case html.TextNode:
			text := strings.TrimSpace(n.Data)
			if len(text) > 0 {
				panic("non-whitespace text at top level: `" + text + "`")
			}
		case html.ErrorNode:
			panic("encountered ErrorNode: " + n.Data)
		case html.ElementNode:
			if n.DataAtom != atom.Template {
				panic("non-template element at top level: <" + n.Data + ">")
			}
			p.processTemplate(n)
		default:
			panic("illegal node at top level: " + n.Data)
		}
	}
}

func (p *processor) dump(htmlPath, packagePath string) {
	htmlFile, err := os.Create(htmlPath)
	if err != nil {
		panic("unable to write HTML output: " + err.Error())
	}
	for i := range p.templates {
		html.Render(htmlFile, p.templates[i].strippedHTML)
	}
	htmlFile.Close()

	_, packageName := filepath.Split(packagePath)

	for i := range p.templates {
		t := p.templates[i]
		if t.kind == macroTmpl {
			continue
		}
		b := strings.Builder{}
		fmt.Fprintf(&b, "package %s\n\n", packageName)
		b.WriteString("import (\n\"github.com/flyx/tbc/runtime\"\n\"github.com/gopherjs/gopherjs/js\"\n)\n")
		fmt.Fprintf(&b, "type %s struct {\n", t.goName)
		b.WriteString("root *js.Object\n")
		for j := range t.objects {
			o := t.objects[j]
			b.WriteString(o.goName)
			b.WriteByte(' ')
			switch o.goType {
			case reflect.Int:
				b.WriteString("runtime.IntValue\n")
			case reflect.String:
				b.WriteString("runtime.StringValue\n")
			default:
				panic("unexpected type of dynamic object")
			}
		}
		fmt.Fprintf(&b, "}\nfunc New%s() *%s {\n", t.goName, t.goName)
		fmt.Fprintf(&b, "root := runtime.InstantiateTemplate(\"%s\")\n", t.id)
		fmt.Fprintf(&b, "return &%s{\n", t.goName)
		b.WriteString("root: root,\n")
		for j := range t.objects {
			o := t.objects[j]
			fmt.Fprintf(&b, "%s: ", o.goName)
			switch o.goType {
			case reflect.Int:
				b.WriteString("runtime.IntValue{")
			case reflect.String:
				b.WriteString("runtime.StringValue{")
			}
			var propertyName string
			switch o.kind {
			case textContent:
				propertyName = "textContent"
			case inputValue:
				propertyName = "value"
			}
			b.WriteString("runtime.NewPropertyAccessor(root, []int{")
			for k := range o.path {
				fmt.Fprintf(&b, "%d, ", o.path[k])
			}
			fmt.Fprintf(&b, "}, \"%s\")},\n", propertyName)
		}
		fmt.Fprintf(&b, "}\n}\nfunc (o *%s) Root() *js.Object {\n", t.goName)
		b.WriteString("return o.root\n}\n")

		fmtcmd := exec.Command("gofmt")

		var stdout bytes.Buffer
		var stderr bytes.Buffer
		fmtcmd.Stdout = &stdout
		fmtcmd.Stderr = &stderr

		stdin, err := fmtcmd.StdinPipe()
		if err != nil {
			panic("unable to create stdin pipe: " + err.Error())
		}
		io.WriteString(stdin, b.String())
		stdin.Close()

		if err := fmtcmd.Run(); err != nil {
			log.Println("error while formatting: " + err.Error())
			log.Println("stderr output:")
			log.Println(stderr.String())
			log.Println("input:")
			log.Println(b.String())
			panic("failed to format Go code")
		}

		path := filepath.Join(packagePath, strings.ToLower(t.goName)+".go")
		ioutil.WriteFile(path, []byte(stdout.String()), os.ModePerm)
	}
}
