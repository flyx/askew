<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1" name="viewport" />
  <meta name="author" content="Felix Krause">
  <title>Askew â€“ Concepts</title>
  <link rel="stylesheet" type="text/css" href="../../static/style.css">
</head>
<body>

  
  <nav>
    <ul>
      <li>
        <a href="../../"
          class="main"
          >Askew</a>
      </li>
      <li>
        <a href="../../doc/concepts/">Documentation</a>
      </li>
      
        <li>
          <a href="../../doc/concepts/"
            class="doc active">Concepts</a>
        </li>
      
        <li>
          <a href="../../doc/components/"
            class="doc">Components</a>
        </li>
      
        <li>
          <a href="../../doc/conditionals/"
            class="doc">Conditionals and Loops</a>
        </li>
      
        <li>
          <a href="../../doc/boundvalues/"
            class="doc">Bound Values</a>
        </li>
      
        <li>
          <a href="../../doc/macros/"
            class="doc">Macros</a>
        </li>
      
        <li>
          <a href="../../doc/generator/"
            class="doc">The Code Generator</a>
        </li>
      
        <li>
          <a href="../../doc/debugging/"
            class="doc">Debugging</a>
        </li>
      
      <li>
        <a href="https://github.com/flyx/askew" style="display:flex;">
          <img src="../../static/gh-logo.png" style="width: 1em; height: 1em; filter: invert(1); margin-right: .5em;"> Repo
        </a>
      </li>
    </ul>
  </nav>
  <main>
    <h1 id="concepts-of-askews-language">Concepts of Askew&rsquo;s Language</h1>
<p>Askew defines a metalanguage based on HTML in which you define the structure of your UI components and the main site.
Basically, you write normal HTML and at certain points you can insert non-HTML elements or attributes that are understood and processed by Askew.
This metalanguage is also named <em>Askew</em>.</p>
<p>In Askew, a <em>UI component</em> is a type whose instances can be inserted at certain predefined locations in the structure of your website.
They behave similarly to <em>widgets</em> in typical GUI libraries.
UI components are defined by the user, there are no predefined components.
The internal HTML used by a component is defined with Askew.</p>
<p>To use your components, you must define the <em>site</em> which contains them.
A site is a single HTML document and is also written in Askew.</p>
<p>The build process of an Askew-based web application is as follows:</p>
<p><img src="../../static/pipeline.svg" alt="Pipeline for using askew to create a website" /></p>
<p>You process all component definitions (<code>*.askew</code>) and the site definition (<code>*.asite</code>) with the askew command line utility, which gives you generated Go source files.
Then you write your application code in Go; this includes adding handlers you declared in your Askew files, for example for handling certain DOM events.
Finally, you compile your code along with the generated code with GopherJS to JavaScript, and that, along with the HTML file generated by Askew, is your website.
(WASM support is not yet implemented.)</p>
<h2 id="the-main-asite-file">The main *.asite file</h2>
<p>Askew allows you to have multiple <code>*.asite</code> files in your module as long as they belong to different modules.
Each <code>*.asite</code> generates an HTML file and for multiple <code>*.asite</code> files, you probably want to also have different <code>main</code> functions per site.
We assume here that you have a single <code>*.asite</code> file.</p>
<p>An <code>*.asite</code> is processed as HTML document.
It must begin with <code>&lt;!doctype html&gt;</code> and contain a single root element named <code>&lt;a:site&gt;</code>.
That element replaces the usual <code>&lt;html&gt;</code> top element of an HTML site and will be rewritten as such when it is processed.
This would be a minimal valid <code>*.asite</code> file:</p>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;a:site lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;title&gt;Test&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Hello, World!&lt;/p&gt;
  &lt;/body&gt;
&lt;/a:site&gt;
</code></pre>
<p>As you can see, you can use <code>&lt;html&gt;</code>&rsquo;s attributes with <code>&lt;a:site&gt;</code>.
Besides those, there are some Askew-specific attributes you can set:</p>
<ul>
<li><code>a:htmlfile</code>: The name of the output HTML file. Defaults to <code>index.html</code>.</li>
<li><code>a:jspath</code>: The path to the JavaScript file created via GopherJS.
Defaults to <code>main.js</code>.</li>
<li><code>a:wasmexecpath</code>: The path to Go&rsquo;s <code>wasm_exec.js</code>.
This is required runtime support when compiling Go to WASM.
you need to make it available at the specified path when using the WASM backend.</li>
<li><code>a:wasmpath</code>: The path to the WASM file created when compiling Go to WASM.</li>
</ul>
<p>The HTML file will be created in the output directory specified as option of the <code>askew</code> command.
The JavaScript path will be written as-is into a <code>&lt;script&gt;</code> tag&rsquo;s <code>src</code> attribute, as will the path to <code>wasm_exec.js</code>.
The path to the WASM file will be loaded via <code>fetch</code>.
Since Askew does call neither GopherJS nor Go&rsquo;s WASM compiler for you, it is your responsibility to provide the <code>.js</code> and <code>.wasm</code> files at the given path.
The generated <code>&lt;script&gt;</code> element will be appended to the end of the <code>&lt;body&gt;</code> element&rsquo;s content.</p>
<h2 id="packages-and-imports">Packages and Imports</h2>
<p>Askew uses Go&rsquo;s concept of packages, i.e. any files in a certain directory are considered to be part of the package defined by that directory.
By default, it is assumed that the package&rsquo;s name equals the directory&rsquo;s name.
You can override this by specifying a <code>&lt;a:package&gt;</code> element, e.g.</p>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;a:site lang=&quot;en&quot;&gt;
  &lt;a:package&gt;main&lt;/a:package&gt;
  &lt;!-- ... --&gt;
&lt;/a:site&gt;
</code></pre>
<p>The either explicitly or implicitly defined package name of an Askew file must match with the package name in any other Askew or Go files in the same package.
This means that <code>&lt;a:package&gt;</code> is required if the current package name differs from the directory&rsquo;s name.</p>
<p>If you want to refer to components defined in other packages, you must import them with an <code>&lt;a:import&gt;</code> Element:</p>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;a:site lang=&quot;en&quot;&gt;
  &lt;a:import&gt;
    &quot;some/package&quot;
    alias &quot;some/other/package&quot;
  &lt;/a:import&gt;
  &lt;!-- .. --&gt;
&lt;/a:site&gt;
</code></pre>
<p>The syntax is identical to the content of the paretheses of Go&rsquo;s <strong><code>import</code></strong> statement.
Askew always implicitly imports the package <code>github.com/flyx/askew/runtime</code>, named <em>askew</em>, so you must not import a package with that name.</p>
<p>In an <code>*.asite</code> file, you must place <code>&lt;a:package&gt;</code> and <code>&lt;a:import&gt;</code> as direct children of the <code>&lt;a:site&gt;</code> element.
You can use those elements also in <code>*.askew</code> files, where you must place them at top level.
You can&rsquo;t place them at top level in an <code>*.asite</code> file because the HTML parser would firmly reject that.</p>
<h2 id="embeds">Embeds</h2>
<p>As we will see in the next chapter, you will define <em>components</em> in <code>*.askew</code> files.
You use those components by <em>embedding</em> them via the <code>&lt;a:embed&gt;</code> element.
This element allows the following attributes:</p>
<ul>
<li>
<p><em>name</em>: Required, must be a valid Go identifier.
The embed generates a value with this name in the generated Go file whereby it can be accessed.
In an <code>*.asite</code> file, a global variable with that name will be generated; inside a component in an <code>*.askew</code> file, a field with that name will be generated inside the current component type.</p>
</li>
<li>
<p><em>type</em>: Must have a value that resolves to a Go type that is a component.
This can be either a type autogenerated from an <code>*.askew</code> file, i.e. a <em>real</em> component, or any <strong><code>interface</code></strong> type that derives from <code>askew.Component</code>, which is an <em>abstract</em> component.
If not given, the default value will be <code>askew.Component</code>.</p>
<p>Embeds that are not <em>optional</em> or a <em>list</em> (see below) will be constructed at initialization time.
This can only be done for <em>real</em> components so any embed of an <em>abstract</em> component must be either <em>optional</em> or a <em>list</em>.</p>
</li>
<li>
<p><em>value</em>: If given, must be a Go expression that evaluates to a value implementing <code>askew.Component</code> and assignable to the <em>type</em> of the embed.
The embed will be initialized by assigning this expression to it.
May not be used on <em>optional</em> or <em>list</em> embeds, and may not be present at the same time as <em>args</em>.</p>
</li>
<li>
<p><em>args</em>: If the embed is not <em>optional</em> nor a <em>list</em> and doesn&rsquo;t have a <em>value</em> attribute, the embed will be a component that will be constructed at initialization time using its constructor (see next chapter).
If that constructor takes arguments, they must be specified via this parameter.
The arguments have standard Go syntax and are comma-separated; it is recommended to use backticks for string literals to avoid HTML escape sequences.
This attribute may not be present on <em>optional</em> or <em>list</em> embeds.</p>
</li>
<li>
<p><em>optional</em>: Valueless attribute. If given, the embed is <em>optional</em>, i.e. you may place a component there any time and remove or replace it again any time.</p>
</li>
<li>
<p><em>list</em>: Valueless attribute, may not be given at the same time as <em>optional</em>.
If given, the embed is a <em>list</em>, i.e. you can put any number of components of the given type in there and remove them again.</p>
</li>
<li>
<p><em>control</em>: Valueless attribute.
Can only be used inside components, not in an <code>*.asite</code> file.
Specifies that the containing component is the default controller of any component embedded here.
Controllers are discussed in the next chapter.</p>
</li>
</ul>
<p>An embed that is neither a <em>list</em> nor an <em>optional</em> is called a <em>direct</em> embed.
The following code shows some examples of embeds in the main site.
Note that <code>&lt;a:embed&gt;</code> is not self-closing and must be properly closed.</p>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;a:site lang=&quot;en&quot;&gt;
  &lt;a:import&gt;
    comps &quot;example.com/components&quot;
  &lt;/a:import&gt;
  &lt;head&gt;
    &lt;title&gt;Example&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;!-- A direct embed of the component named &quot;header&quot; which must be defined
         in the same package. The component's constructor will be called with
         the arguments (`Title`, `Subtitle`). --&gt;
    &lt;a:embed name=&quot;Header&quot; type=&quot;header&quot; args=&quot;`Title`, `Subtitle`&quot;&gt;&lt;/a:embed&gt;
    &lt;nav&gt;&lt;ul&gt;
      &lt;!-- A list embed.
           Can contain any number of components of the type &quot;comps.NavItem&quot;,
           which is defined in the package comps that has been imported above.
           That type may be a component, but may also a Go interface. --&gt;
      &lt;a:embed name=&quot;NavItems&quot; type=&quot;comps.NavItem&quot; list&gt;&lt;/a:embed&gt;
    &lt;/ul&gt;&lt;/nav&gt;
    &lt;main&gt;
      &lt;!-- The main content of the page. Has no type, which means that any
           component can be put here. This requires the embed to be optional.
           Initially, it will be empty. --&gt;
      &lt;a:embed name=&quot;Content&quot; optional&gt;&lt;/a:embed&gt;
    &lt;/main&gt;
  &lt;/body&gt;
&lt;/a:site&gt;
</code></pre>
<p>For <em>list</em> and <em>optional</em> embeds, you can explicitly construct the initial component(s) that should be contained.
You do this with the element <code>&lt;a:construct&gt;</code>, which must be put inside the <code>&lt;a:embed&gt;</code>.
<code>&lt;a:construct&gt;</code> allows the following attributes:</p>
<ul>
<li><code>type</code>: Optional, defaults to the parent <code>&lt;a:embed&gt;</code>&rsquo;s type.
Must be a <em>real</em> component, so it must be set if the parent <code>&lt;a:embed&gt;</code>&rsquo;s type is abstract.
If given, the value returned from the type&rsquo;s constructor must be assignable to the parent <code>&lt;a:embed&gt;</code>&rsquo;s type.</li>
<li><code>args</code>: Optional. Must be given if the type&rsquo;s constructor takes arguments.
Parses just like the <code>&lt;a:embed&gt;</code> attribute of the same name.</li>
<li><code>a:if</code>, <code>a:for</code>: May be used for conditional or looped constructing, see the chapter on control structures.</li>
</ul>
<p>An optional <code>&lt;a:embed&gt;</code> may contain at most one <code>&lt;a:construct&gt;</code> which may not have a <code>a:for</code>, a list may contain any number of <code>&lt;a:construct&gt;</code>s, a direct embed may not contain any.</p>
<h2 id="the-main-function">The main function</h2>
<p>Just like with regular Go code, you must write a <code>main</code> function as entry point.
When compiling to WASM, this main file must not exit if you want event handlers to work.
You can call <code>askew.KeepAlive()</code> to do this, it is a nop when compiling with GopherJS.</p>

  </main>

</body>
</html>
