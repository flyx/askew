title: Components
date: 2021-01-30
----

# Components

Components are Askew's most important structure.
They are defined in `.askew` files, and each component defined there will generate a `struct` type in the generated Go code which implements `runtime.Component`.

## Name and Visibility

A component is defined with a `<a:component>` element at top level:

```html
<a:component name="MyComponent">
  <p>Hello, World!</p>
</a:component>
```

It must have a `name` attribute, whose value must be a valid Go identifier.
This value will be the name of the generated `struct` type.
Lowercase names will make the component only be usable within the current package.
The name must not collide with any other names, regardless of whether they are defined via Askew or in your Go code.

## Parameters and Construction

A component can have *parameters*.
Parameters are values given when creating a component instance and can be used to initialize the component's HTML.
Parameters are given via the attribute *params* and have the same syntax as Go **`func`** params:

```html
<a:component name="foo" params="name, dayDescr string">
  <p>Hello, <a:text expr="name"></a:text>!</p>
  <p>Have a <a:text expr="dayDescr"><a:text> day.</p>
</a:component>
```

In this example, `<a:text>` is used to insert the value of the given Go expression as text when initializing the component.

For every component, a method `askewInit` will be created.
It will take the parameters defined in `params` (or none, if it wasn't given) and return nothing.
This is considered an internal function that must be called from the component's *init* or *new* func.

Askew expects every component to have both an *init* and a *new* func.
The *init* func is always a method with the name `Init` and must not return anything.
The *new* func must be a standalone function with the name `new<c-name>` for private and `New<c-name>` for public components and must return a pointer to the component struct.
`<c-name>` stands for the capitalized component's name, i.e. the first letter is converted into uppercase.

Both the *new* and the *init* funcs must call `askewInit`.
The *init* func is called by Askew for direct `<a:embed>`s.
The *new* func is called by Askew for `<a:construct>`s inside list or optional embeds.

You can either let Askew autogenerate the funcs or write them yourself.
Autogenerating them will have them take the same parameters as `askewInit`.
An autogenerated *new* func will create a component with the **`new`** keyword and call `askewInit` on it.
An autogenerated *init* func will call `askewInit` on the subject.
You tell Askew to autogenerate the *new* and *init* func by giving the valueless attribute `gen-new-init` on the component:

```html
<a:component name="foo" params="name string" gen-new-init>
  <p>Hello, <a:text expr="name"></a:text>!</p>
</a:component>
<!-- the following initialization functions will be generated:
func newFoo(name string) {
  ret := new(foo)
  ret.askewInit(name)
}
func (o *foo) init(name string) {
  o.askewInit(name)
}
func (o *foo) askewInit(name string) {â€¦} // always generated
-->

<a:component name="bar">
  <!-- Renders the paragraph with "Hello, World!" -->
  <a:embed name="f" type="foo" args="`World`"></a:embed>
</a:component>
```

If you need to do additonal initialization or calculate the arguments for `askewInit` internally, instead of autogenerating the functions, you can write them yourself.
You are free to choose different parameters for your functions, as long as you can supply proper arguments to `askewInit`, which you must call in those functions.
If Askew calls your funcs via `<a:embed>` or `<a:construct>`, the `args` given there need to fit the parameters of your *init* / *new* funcs.

The following example manually defines *new*/*init* funcs for the component `greeter` and calls them in `bar`:

```html
<!-- html code -->
<a:component name="greeter" params="name string">
  <p>Hello, <a:text expr="name"></a:text>!</p>
</a:component>

<a:component name="bar" gen-new-init>
  <!-- calls user-defined Init() and results in "Hello, Dr. Evil!" -->
  <a:embed type="greeter" args="true, `Evil`"></a:embed>
</a:component>
```
```go
// go code

func newGreeter(isDr bool, name string) *greeter {
  ret := new(greeter)
  ret.Init(isDr, name)
  return ret
}

func (o *greeter) Init(isDr bool, name string) {
  if isDr {
    o.askewInit("Dr. " + name)
  } else {
    o.askewInit(name)
  }
}
```

Mind that in generated code, the subject of methods is always named *o*.
While Go does not forbid you to name it differently in your methods, GopherJS seems to be confused when you use a different name, so you should always name the subject *o*.

## Assignments

